/* Copyright Statement:
*
* This software/firmware and related documentation ("MediaTek Software") are
* protected under relevant copyright laws. The information contained herein
* is confidential and proprietary to MediaTek Inc. and/or its licensors.
* Without the prior written permission of MediaTek inc. and/or its licensors,
* any reproduction, modification, use or disclosure of MediaTek Software,
* and information contained herein, in whole or in part, shall be strictly prohibited.
*/
/* MediaTek Inc. (C) 2021. All rights reserved.
*
* BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
* THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
* RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
* AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
* NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
* SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
* SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
* THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
* THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
* CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
* SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
* STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
* CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
* AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
* OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
* MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*/

/*
 * @file    src_coordinator.c
 * @brief   Driver for src_coordinator control
 */

#include <typedefs.h>
#include <platform.h>

#include "src_coordinator.h"

#define CHANNEL_CNT			6

/* output channel select */
#define SRCLKEN_RC_OUTPUT		0
#define SRC_COORDINATOR_OUTPUT		0x1
#define OUTPUT_CHANNEL_MASK		0x3

#define PMIF_OUT_SHIFT			0
#define PO_PWRAP_CLD_SHIFT		2
#define PO_PWRAP_SLEEP_REQ_SHIFT	4
#define PO_SRCLKEN_PWRAP_SHIFT		6
#define PO_SCP_PWRAP_SLEEP_ACK_SHIFT	8
#define PO_SCP_VREQ_ACK_SHIFT		10
#define PO_SRCLKEN_SHIFT		12

/* Channel PMIF HWINF config */
#define PMIF_HWINF_SETTING(chn)		(PMIF_HWINF_SETTING_I0_ADDR \
						+ (uint32)(chn * 4))
#define PMIF_CMD_TYPE_MASK		0x3
#define PMIF_CMD_TYPE_SHIFT		22
#define PMIF_CMD_BURST_RW		0x3

#define PMIF_CMD_BYTE_CNT_MASK		0x1
#define PMIF_CMD_BYTE_CNT_SHIFT		21
#define PMIF_CMD_2BYTE			1

#define PMIF_SLV_ID_MASK		0xF
#define PMIF_SLV_ID_SHIFT		16
#define PMIF_SLV_ID			0xB /* GROUP ID */

#define PMIF_CMD_ADDR_MASK		0xFFFF
#define PMIF_CMD_ADDR_SHIFT		0
#define PMIF_CMD_VOLT_ADDR		0x260
#define PMIF_CMD_DCXO_ADDR		0x190

/* PMIF config */
#define MASK_PMIF1_RDY_MASK		0x1
#define MASK_PMIF1_RDY_SHIFT		10
#define MASK_PMIF1_RDY_EN		1

#define PMIF0_EN_MASK			0x1
#define PMIF0_EN_SHIFT			9
#define PMIF0_EN			1

#define PMIF0_ID_MASK			0x1
#define PMIF0_ID_SHIFT			8
#define PMIF0_ID			0

#define PMIF1_EN_MASK			0x1
#define PMIF1_EN_SHIFT			7
#define PMIF1_DIS			0

#define PMIF1_ID_MASK			0x1
#define PMIF1_ID_SHIFT			6
#define PMIF1_ID			1

#define ISSUE_CMD_TO_PMIF1_MASK		0x3F
#define ISSUE_CMD_TO_PMIF1_SHIFT	0
#define ISSUE_CMD_TO_PMIF1_DIS		0

/* setting time setting */
#define TURN_ON_SETTLE_TIME(chn)	(TURN_ON_SETTLE_TIME_I0_ADDR \
						+ (uint32)(chn * 4))
#define TURN_OFF_SETTLE_TIME(chn)	(TURN_OFF_SETTLE_TIME_I0_ADDR \
						+ (uint32)(chn * 4))
#define VOLT_ONOFF_SETTLE_TIME		0x1474
#define DCXO_ONOFF_SETTLE_TIME		0x28E8
#define DCXO_PHASE_SETTLE_TIME		0x3CF1
#define VCORE_SETTLE_TIME		0x1474

#define REQ_SEL(chn)			(REQ_SEL_I0_ADDR + (uint32)(chn * 4))
#define REQ_MASK(chn)			(REQ_MASK_I0_ADDR + (uint32)(chn * 4))

int src_coordinator_init(void)
{
#if !defined(SRC_COORDINATOR_BRINGUP) && SRC_COORDINATOR_SUPPORT
	uint8 chn = 0;

	DRV_WriteReg32(SW_CG_EN_ADDR, 0);

	DRV_WriteReg32(SW_RST_ADDR, 0);

	DRV_WriteReg32(OUTPUT_CHANNEL_SEL_ADDR,
		SRC_COORDINATOR_OUTPUT << PMIF_OUT_SHIFT |
		SRC_COORDINATOR_OUTPUT << PO_PWRAP_CLD_SHIFT |
		SRC_COORDINATOR_OUTPUT << PO_PWRAP_SLEEP_REQ_SHIFT |
		SRC_COORDINATOR_OUTPUT << PO_SRCLKEN_PWRAP_SHIFT |
		SRC_COORDINATOR_OUTPUT << PO_SCP_PWRAP_SLEEP_ACK_SHIFT |
		SRC_COORDINATOR_OUTPUT << PO_SCP_VREQ_ACK_SHIFT |
		SRC_COORDINATOR_OUTPUT << PO_SRCLKEN_SHIFT);

	for (chn = 0; chn < CHANNEL_CNT - 1; chn++) {
		DRV_WriteReg32(PMIF_HWINF_SETTING(chn),
			PMIF_CMD_BURST_RW << PMIF_CMD_TYPE_SHIFT |
			PMIF_CMD_2BYTE << PMIF_CMD_BYTE_CNT_SHIFT |
			PMIF_SLV_ID << PMIF_SLV_ID_SHIFT |
			PMIF_CMD_VOLT_ADDR << PMIF_CMD_ADDR_SHIFT);
	}

	DRV_WriteReg32(PMIF_HWINF_SETTING(chn + 1),
		PMIF_CMD_BURST_RW << PMIF_CMD_TYPE_SHIFT |
		PMIF_CMD_2BYTE << PMIF_CMD_BYTE_CNT_SHIFT |
		PMIF_SLV_ID << PMIF_SLV_ID_SHIFT |
		PMIF_CMD_DCXO_ADDR << PMIF_CMD_ADDR_SHIFT);

	DRV_WriteReg32(PMIF_SETTING_ADDR,
		MASK_PMIF1_RDY_EN << MASK_PMIF1_RDY_SHIFT |
		PMIF0_EN << PMIF0_EN_SHIFT |
		PMIF0_ID << PMIF0_ID_SHIFT |
		PMIF1_DIS << PMIF1_EN_SHIFT |
		PMIF1_ID << PMIF1_ID_SHIFT |
		ISSUE_CMD_TO_PMIF1_DIS << ISSUE_CMD_TO_PMIF1_SHIFT);

	for (chn = 0; chn < CHANNEL_CNT - 1; chn++) {
		DRV_WriteReg32(TURN_ON_SETTLE_TIME(chn),
			VOLT_ONOFF_SETTLE_TIME);
		DRV_WriteReg32(TURN_OFF_SETTLE_TIME(chn),
			VOLT_ONOFF_SETTLE_TIME);
	}

	DRV_WriteReg32(TURN_ON_SETTLE_TIME(chn + 1),
		DCXO_ONOFF_SETTLE_TIME);
	DRV_WriteReg32(TURN_OFF_SETTLE_TIME(chn + 1),
		DCXO_ONOFF_SETTLE_TIME);

	DRV_WriteReg32(DCXO_PHASE_SHIFT_SETTLING_TIME_ADDR,
		DCXO_PHASE_SETTLE_TIME);

	DRV_WriteReg32(VCORE_SETTLING_TIME_ADDR,
		VCORE_SETTLE_TIME);

	/* all channel use cmd off table for final cmd */
	DRV_WriteReg32(INIT_NO_REQ_CMD_SETTING_ADDR, 0x3F);

	/* channel 6 use srclken_rc command mode */
	DRV_WriteReg32(SRCLKEN_RC_EMULATION_MODE_ADDR, 1);

	DRV_WriteReg32(CMD_TABLE_I3_M14_ADDR, 0x20000);
	DRV_WriteReg32(CMD_TABLE_I3_M15_ADDR, 0x80000);
	DRV_WriteReg32(CMD_TABLE_I3_M16_ADDR, 0xA00000);
	DRV_WriteReg32(CMD_TABLE_I3_M17_ADDR, 0x2000000);
	DRV_WriteReg32(CMD_TABLE_I4_M14_ADDR, 0x20000);
	DRV_WriteReg32(CMD_TABLE_I4_M15_ADDR, 0x80000);
	DRV_WriteReg32(CMD_TABLE_I4_M16_ADDR, 0xA00000);
	DRV_WriteReg32(CMD_TABLE_I4_M17_ADDR, 0x2000000);

	DRV_WriteReg32(CMD_TABLE_I5_M0_ADDR, 0x40018000);
	DRV_WriteReg32(CMD_TABLE_I5_M1_ADDR, 0x40028000);
	DRV_WriteReg32(CMD_TABLE_I5_M2_ADDR, 0x40048000);
	DRV_WriteReg32(CMD_TABLE_I5_M3_ADDR, 0x40088000);
	DRV_WriteReg32(CMD_TABLE_I5_M4_ADDR, 0x40108000);
	DRV_WriteReg32(CMD_TABLE_I5_M5_ADDR, 0x40208000);
	DRV_WriteReg32(CMD_TABLE_I5_M6_ADDR, 0x40408000);
	DRV_WriteReg32(CMD_TABLE_I5_M7_ADDR, 0x40808000);
	DRV_WriteReg32(CMD_TABLE_I5_M8_ADDR, 0x41008000);
	DRV_WriteReg32(CMD_TABLE_I5_M9_ADDR, 0x42008000);
	DRV_WriteReg32(CMD_TABLE_I5_M10_ADDR, 0x44008000);
	DRV_WriteReg32(CMD_TABLE_I5_M11_ADDR, 0x48018000);
	DRV_WriteReg32(CMD_TABLE_I5_M12_ADDR, 0x50018000);
	DRV_WriteReg32(CMD_TABLE_I5_M13_ADDR, 0x60018000);

	/* voltage channel m00 ~ m31 to SW mode */
	for (chn = 0; chn < CHANNEL_CNT - 1; chn++) {
		DRV_WriteReg32(REQ_SEL(chn), 0xFFFFFFFF);
	}

	/* dcxo channel to HW/SW mode */
#if SRC_COORDINATOR_DCXO_HW
	DRV_WriteReg32(REQ_SEL(chn + 1), 0xFFFFC000);
#else /* !SRC_COORDINATOR_DCXO_HW */
	DRV_WriteReg32(REQ_SEL(chn + 1), 0xFFFFFFFF);
#endif /* SRC_COORDINATOR_DCXO_HW */

	/* unmask enabled channel */
	for (chn = 0; chn < CHANNEL_CNT - 3; chn++) {
		DRV_WriteReg32(REQ_MASK(chn), 0xFFFFFFFF);
	}
	DRV_WriteReg32(REQ_MASK(3), 0x3FFF);
	DRV_WriteReg32(REQ_MASK(4), 0xFFC3FFF);
	DRV_WriteReg32(REQ_MASK(5), 0xFFFFC000);

	DRV_WriteReg32(SW_RST_ADDR, 0);

	DRV_WriteReg32(SW_CG_EN_ADDR, 1);

#endif /* !defined(SRC_COORDINATOR_BRINGUP) && SRC_COORDINATOR_SUPPORT) */
	return 0;
}
